<h1>Содержание урока </h1>
1. Рассмотрение понятия наследования.  </br> 
2. Обзор и применение модификаторов доступа.  </br> 
3. Вызов конструктора базового класса.  </br> 
4. Приведение к базовому типу.  </br> 
5. Понятие Upcast-а и DownCast-а.  </br> 
6. Рассмотрение понятия полиморфизма.  </br> 
1. Операторы Is и As.  </br> 
2. Cast с использованием оператора as  </br> 
7. Использование герметизированных классов.  </br> 

<h1>Резюме  </h1>
· ООП - Объектно-ориентированное программирование — парадигма программирования, в которой основными концепциями являются понятия объектов и классов. </br> 
· Наследование — механизм объектно-ориентированного программирования (наряду с инкапсуляцией, полиморфизмом и абстракцией), 
позволяющий описать новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского 
класса заимствуются новым классом. </br>   
· Недостаток наследования – хрупкий базовый класс. Хрупкий базовый класс — фундаментальная проблема объектно-ориентированного программирования. Проблема хрупкого базового класса заключается в том, что малейшие правки в деталях реализации базового класса могут привнести ошибку в производные классы. В худшем случае это приводит к тому, что любая успешная модификация базового класса требует предварительного изучения всего дерева наследования, и зачастую невозможна (без создания ошибок) даже в этом случае.  </br> 
· Рекомендуется использовать следующие пары:  </br> 
Базовый класс – Производный класс  </br> 
Супер класс - Подкласс или (сабкласс)  </br> 
Родительский класс - Дочерний класс  </br> 
Класс Родитель – Класс Потомок </br>  
 </br> 
· Модификаторы доступа – это ключевые слова, задающие объявленную доступность члена или типа. При помощи модификаторов доступа можно задать следующие пять уровней доступности:  </br> 
	1) public - доступ к типу или члену возможен из любого другого кода в той же сборке или другой сборке, ссылающейся на него.  </br> 
	2) protected - доступ к типу или элементу можно получить только из кода в том же классе или структуре, либо в производном классе.  </br> 
	3) internal - доступ к типу или члену возможен из любого кода в той же сборке, но не из другой сборки.  </br> 
	4) protected internal - доступ ограничен текущей сборкой или типами, которые являются производными от содержащего класса.  </br> 
	5) private - доступ к типу или члену можно получить только из кода в том же классе или структуре.  </br> 
· Полиморфизм — возможность объектов с одинаковой спецификацией иметь различную реализацию.  </br> 
· Полиморфизм предоставляет подклассу способ определения собственной версии   
метода, определенного в его базовом классе, с использованием процесса, который    </br> 
называется переопределением метода (method overriding).  </br> 
· Базовые классы могут определять и реализовывать виртуальные методы, а производные классы могут переопределять их. Это означает, что они предоставляют свои собственные определение и реализацию.  </br> 
· Во время выполнения, когда клиентский код вызывает метод, среда CLR ищет тип времени выполнения объекта и вызывает это переопределение виртуального метода. Таким образом, в исходном коде можно вызвать метод в базовом классе и вызвать выполнение метода с версией производного класса.  </br> 
· Если производный класс наследует от базового класса, то он приобретает все методы, поля, свойства и события базового класса. Проектировщик производного класса может выбирать из следующих возможностей:   </br> 
1) переопределить виртуальные члены в базовом классе  </br> 
2) наследовать метод последнего базового класса без его переопределения  </br> 
3) определить новую не виртуальную реализацию этих членов, которая скрывает реализации базового класса.  </br> 
· Поля не могут быть виртуальными.   </br> 
· Виртуальными могут быть только методы, свойства, события и индексаторы.  </br> 
· Если в производном классе виртуальный метод переопределяется, то этот член вызывается даже в том случае, если доступ к экземпляру этого класса осуществляется как к экземпляру базового класса.  </br> 
· Виртуальные методы и свойства дают возможность производным классам расширять базовый класс, без необходимости использования реализации метода базового класса.  </br> 
· Если необходимо, чтобы производный член имел то же имя, что и член базового класса, но не нужно, чтобы он участвовал в виртуальном вызове, можно использовать ключевое слово new. Ключевое слово new располагается перед возвращаемым типом замещаемого члена класса.  </br> 
· Оператор is - проверяет совместимость объекта с заданным типом.  </br> 
· Если предоставленный объект может быть приведен к предоставленному типу не вызывая исключение, выражение is принимает значение true. </br>  
· Оператор as используется для выполнения преобразований между совместимыми ссылочными типами  </br> 
· Оператор as подобен оператору приведения. Однако, если преобразование невозможно, as возвращает значение null, а не вызывает исключение  </br> 
· В общем виде логика работы оператора as представляет собой механизм использования оператора is, только в сокращенном виде </br>  
· Ключевое слово — sealed, которое предотвращает наследование. Если класс помечен как sealed (запечатанный), компилятор не позволяет наследовать от него. Считается, что класс герметизирован или «запечатан».  </br> 
